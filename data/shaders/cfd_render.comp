#version 450

#include "common.glsl"

layout(binding = 2, rgba8) uniform writeonly image2D image;

const float M_PI = 3.1415926535897932384626433832795;

void main()
{
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
    uint index = gl_GlobalInvocationID.y * ubo.gridSize.x + gl_GlobalInvocationID.x;
    index = pc.readBufferOffset + index;

    // Load variables from the read buffer
    vec2 velocity = data[index].velocity;
    float density = data[index].density;
    float gamma = 2.2;

    // calculate velocity magnitude
    float velocityMagnitude = length(data[index].velocity);
    float maxVelocity = 1.00;

    // Normalize the velocity to the range [0, 1]
    float normalizedVelocity =
            velocityMagnitude / maxVelocity; // maxVelocity is the maximum possible velocity

    //////////////////////////////////////////

    // vec3 color;
    // if(normalizedVelocity < 0.5)
    // {
    //     // Linearly interpolate between blue and green for velocities in the range [0, 0.5]
    //     color = mix(vec3(0.0, 0.0, 1.0), vec3(0.0, 1.0, 0.0), normalizedVelocity * 2.0);
    // }
    // else
    // {
    //     // Linearly interpolate between green and red for velocities in the range [0.5, 1]
    //     color = mix(vec3(0.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0), (normalizedVelocity - 0.5) * 2.0);
    // }
    //
    // // Store to image
    // imageStore(image, pos, vec4(color, 1.0));

    //////////////////////////////////////////
    /// LOG VELOCITY

    float logVelocity = log2(normalizedVelocity * 8.0*64.0*1 + 1.0) / (4.0*1.0); // Adjust the constants as needed

       vec3 color;
    if(logVelocity < 0.33)
    {
        // Linearly interpolate between black and purple for velocities in the range [0, 0.33]
        color = mix(vec3(0.0, 0.0, 0.0), vec3(0.5, 0.0, 0.5), logVelocity * 3.0);
    }
    else if(logVelocity < 0.66)
    {
        // Linearly interpolate between purple and orange for velocities in the range [0.33, 0.66]
        color = mix(vec3(0.5, 0.0, 0.5), vec3(1.0, 0.5, 0.0), (logVelocity - 0.33) * 3.0);
    }
    else
    {
        // Linearly interpolate between orange and white for velocities in the range [0.66, 1]
        color = mix(vec3(1.0, 0.5, 0.0), vec3(1.0, 1.0, 1.0), (logVelocity - 0.66) * 3.0);
    }

    // Store to image
    imageStore(image, pos, vec4(color, 1.0));


    //////////////////////////////////////////
    /// DENSITY

    // float logDensity = log2(density * 8.0 + 1.0) / (4.0*2.0); // Adjust the constants as needed
    // vec3 color;
    // if(logDensity < 0.33)
    // {
    //     // Linearly interpolate between black and purple for velocities in the range [0, 0.33]
    //     color = mix(vec3(0.0, 0.0, 0.0), vec3(0.5, 0.0, 0.5), logDensity * 3.0);
    // }
    // else if(logDensity < 0.66)
    // {
    //     // Linearly interpolate between purple and orange for velocities in the range [0.33, 0.66]
    //     color = mix(vec3(0.5, 0.0, 0.5), vec3(1.0, 0.5, 0.0), (logDensity - 0.33) * 3.0);
    // }
    // else
    // {
    //     // Linearly interpolate between orange and white for velocities in the range [0.66, 1]
    //     color = mix(vec3(1.0, 0.5, 0.0), vec3(1.0, 1.0, 1.0), (logDensity - 0.66) * 3.0);
    // }
    //
    // imageStore(image, pos, vec4(color, 1.0));

    //////////////////////////////////////////
    /// TANGENT

    // Compute the tangent of the velocity vector
    // GridCell cell = data[index];
    // float tangent = atan(cell.velocity.y, cell.velocity.x);
    //
    // // Map the tangent from the range [-pi, pi] to [0, 1]
    // float normalizedTangent = (tangent + M_PI) / (2.0 * M_PI);
    //
    // vec3 color;
    // if(normalizedTangent < 0.5)
    // {
    //     // Linearly interpolate between black and red for tangents in the range [0, 0.5]
    //     color = mix(vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), normalizedTangent * 2.0);
    // }
    // else
    // {
    //     // Linearly interpolate between red and blue for tangents in the range [0.5, 1]
    //     color = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), (normalizedTangent - 0.5) * 2.0);
    // }
    //
    // // Store to image
    // imageStore(image, pos, vec4(color, 1.0));

    //////////////////////////////////////////

    // vec4 color = vec4(vec3(density), 1.0);
    // color = vec4(pow(color.xyz, vec3(1.0 / gamma)), 1.0);
    //
    // float sum = density + velocityMagnitude;
    // sum = clamp(sum, 0.0, 1.0);
    //
    // // Store to image
    // imageStore(image, pos, vec4(vec3(color), 1.0));
    // // imageStore(image, pos, vec4(vec3(velocityMagnitude), 1.0));
}
