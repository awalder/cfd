#version 450

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(binding = 0) uniform UniformBufferObject
{
    vec4 color;
    ivec2 gridSize;
    float time;
}
ubo;

struct GridCell
{
    vec2 velocity;
    vec2 externalForce;
    float pressure;
    float density;
    float temperature;
    int boundaryType;
};

layout(std140, binding = 1) buffer Grid
{
    GridCell data[];
};

layout(push_constant) uniform PushConstants
{
    uint readBufferOffset;
    uint writeBufferOffset;
}
pc;

GridCell getCell(ivec2 pos, ivec2 offset)
{
    ivec2 neighborPos = pos + offset;
    uint index = neighborPos.y * ubo.gridSize.x + neighborPos.x + pc.readBufferOffset;
    return data[index];
}

void main()
{
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
    uint index = gl_GlobalInvocationID.y * ubo.gridSize.x + gl_GlobalInvocationID.x;
    uint readIndex = pc.readBufferOffset + index;
    uint writeIndex = pc.writeBufferOffset + index;

    if(pos.x >= ubo.gridSize.x || pos.y >= ubo.gridSize.y)
    {
        return;
    }

    if(data[readIndex].boundaryType != 0)
    {
        return;
    }

    float dt0 = ubo.time * float(ubo.gridSize.x);
    vec2 x = vec2(pos) - dt0 * data[readIndex].velocity;

    if(x.x < 0.5)
        x.x = 0.5;
    if(x.x > float(ubo.gridSize.x) + 0.5)
        x.x = float(ubo.gridSize.x) + 0.5;
    int i0 = int(x.x);
    int i1 = i0 + 1;

    if(x.y < 0.5)
        x.y = 0.5;
    if(x.y > float(ubo.gridSize.y) + 0.5)
        x.y = float(ubo.gridSize.y) + 0.5;
    int j0 = int(x.y);
    int j1 = j0 + 1;

    float s1 = x.x - float(i0);
    float s0 = 1.0 - s1;
    float t1 = x.y - float(j0);
    float t0 = 1.0 - t1;

    GridCell cell_i0_j0 = getCell(ivec2(i0, j0), ivec2(0, 0));
    GridCell cell_i0_j1 = getCell(ivec2(i0, j1), ivec2(0, 0));
    GridCell cell_i1_j0 = getCell(ivec2(i1, j0), ivec2(0, 0));
    GridCell cell_i1_j1 = getCell(ivec2(i1, j1), ivec2(0, 0));

    data[writeIndex].density = s0 * (t0 * cell_i0_j0.density + t1 * cell_i0_j1.density)
                               + s1 * (t0 * cell_i1_j0.density + t1 * cell_i1_j1.density);
}
